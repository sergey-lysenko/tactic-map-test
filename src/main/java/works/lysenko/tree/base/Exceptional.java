package works.lysenko.tree.base;

import org.openqa.selenium.WebElement;
import works.lysenko.tree.base.exceptional.Core;
import works.lysenko.util.apis.exception.checked.SafeguardException;
import works.lysenko.util.prop.core.Recreate;

import java.util.List;

import static java.lang.System.lineSeparator;
import static java.util.Objects.isNull;
import static org.apache.commons.lang3.StringUtils.removeEnd;
import static org.apache.commons.lang3.StringUtils.removeStart;
import static works.lysenko.Base.core;
import static works.lysenko.Base.exec;
import static works.lysenko.util.Constants._ANDROID_WIDGET_TEXTVIEW;
import static works.lysenko.util.chrs.__.TO;
import static works.lysenko.util.data.enums.Ansi.bb;
import static works.lysenko.util.data.enums.Severity.S0;
import static works.lysenko.util.data.enums.Severity.S1;
import static works.lysenko.util.data.records.KeyValue.kv;
import static works.lysenko.util.data.strs.Bind.b;
import static works.lysenko.util.data.strs.Case.c;
import static works.lysenko.util.data.strs.Swap.s;
import static works.lysenko.util.data.strs.Vars.a;
import static works.lysenko.util.data.strs.Wrap.q;
import static works.lysenko.util.func.imgs.Screenshot.makeScreenshot;
import static works.lysenko.util.func.type.Objects.isNotNull;
import static works.lysenko.util.lang.A.ANDROID_LAUNCHER;
import static works.lysenko.util.lang.A.AN_ELEMENT___;
import static works.lysenko.util.lang.C.COMMA_SPACE;
import static works.lysenko.util.lang.E.EXPECTED_CONDITION_FAILED___;
import static works.lysenko.util.lang.O.OOS;
import static works.lysenko.util.lang.O.OOSR;
import static works.lysenko.util.lang.P.PROVIDED_LOCATOR;
import static works.lysenko.util.lang.S.S_E_R_EXCEPTION;
import static works.lysenko.util.lang.T.TIMEOUT_EXCEPTION;
import static works.lysenko.util.lang.T.TRIED_FOR_30_SECONDS___;
import static works.lysenko.util.lang.U.UNRESOLVED___;
import static works.lysenko.util.lang.U.U_B_EXCEPTION;
import static works.lysenko.util.lang.W.WAS_NOT_REACHABLE;
import static works.lysenko.util.lang.word.A.ANTEPENULTIMATE;
import static works.lysenko.util.lang.word.A.ATTEMPTING;
import static works.lysenko.util.lang.word.E.EXCEPTION;
import static works.lysenko.util.lang.word.E.EXCEPTIONS;
import static works.lysenko.util.lang.word.O.OTHER;
import static works.lysenko.util.lang.word.P.PENULTIMATE;
import static works.lysenko.util.lang.word.R.RESOLVE;
import static works.lysenko.util.lang.word.S.SELENIUM;
import static works.lysenko.util.lang.word.U.ULTIMATE;
import static works.lysenko.util.lang.word.V.VERIFYING;
import static works.lysenko.util.spec.Symbols.*;

/**
 * This Scenario executed to handle Exceptions during test run
 */
@SuppressWarnings("AbstractClassWithOnlyOneDirectInheritor")
public abstract class Exceptional extends Core {

    private static final String TEXT_VIEW_TEXT = "TextView[@text="; //NON-NLS
    private static final String AVAILABLE_TEXTS_OF_TEXT_VIEW_ELEMENTS = "Available texts of TextView elements: "; //NON-NLS

    @SuppressWarnings("DesignForExtension")
    @Override
    public void action() throws SafeguardException {

        header();
        selenium();
        other();
    }

    /**
     * Handles an "other" exceptional condition during testing sessions by logging a specific message and
     * taking additional steps if unresolved states are detected.
     * <p>
     * This method performs the following operations:
     * - Logs a message that combines information generated by helper methods responsible for
     * string capitalization, formatting, and applying specific styling.
     * - Checks whether the current state is unresolved using the {@code unresolved()} method.
     * - If unresolved, invokes the {@code notResolved()} method to handle the state accordingly.
     * <p>
     * The method is intended for internal use within the Exceptional class hierarchy for dealing
     * with specific cases during testing scenarios.
     */
    private void other() {

        log(bb(b(c(VERIFYING), c(OTHER), EXCEPTIONS)));
        // none for now
        if (unresolved()) notResolved();
    }

    /**
     * Handles Selenium-specific exceptional cases during testing sessions.
     * <p>
     * This method performs the following operations:
     * - Logs a message constructed with the methods for string formatting and styling.
     * - Retrieves the root cause of the exception from the triplet object.
     * - If a root cause exists and matches known exception types, resolves the issue using appropriate methods:
     * - {@code resolveTimeout(Throwable)} for timeout exceptions.
     * - {@code resolveStale()} for stale element reference exceptions.
     * - {@code resolveBrowser()} for browser-specific exceptions.
     */
    @SuppressWarnings("CallToSuspiciousStringMethod")
    private void selenium() {

        log(bb(b(c(VERIFYING), c(SELENIUM), EXCEPTIONS)));
        final Throwable exception = triplet().ultimate();
        if (isNotNull(exception)) {
            final String causeName = exception.getClass().getName();
            if (causeName.equals(b(_DOT_, OOS, TIMEOUT_EXCEPTION))) resolveTimeout(exception);
            if (causeName.equals(b(_DOT_, OOS, S_E_R_EXCEPTION))) resolveStale();
            if (causeName.equals(b(_DOT_, OOSR, U_B_EXCEPTION))) resolveBrowser();
        }
    }

    /**
     * Logs diagnostic information regarding the current exception and the associated objects,
     * while making a screenshot for debugging purposes.
     * <p>
     * This method performs the following operations:
     * - Retrieves and logs the class name of the current exception using the {@code exception()} method.
     * - Determines and logs the class names of the ultimate, penultimate, and antepenultimate elements
     * in the triplet object if they are not {@code null}, using the {@code triplet()} method.
     * - Escalates the provided ultimate element's state by invoking {@code makeScreenshot(String...)}
     * with its class name for further debugging through logging.
     * - Formats a message containing key-value information about the exception and the triplet elements,
     * using various helper methods like {@code kv()}, {@code b()}, {@code c()}, and {@code a()}.
     * - Logs the constructed message for debugging using the {@code logDebug(String)} method.
     * <p>
     * This method is designed for internal usage within the containing class hierarchy to facilitate
     * debugging and issue resolution during exceptional scenarios in testing or runtime processes.
     */
    private void header() {

        final String eName = exception().getClass().getName();
        final String uName = isNull(triplet().ultimate()) ? null : triplet().ultimate().getClass().getName();
        final String pName = isNull(triplet().penultimate()) ? null : triplet().penultimate().getClass().getName();
        final String aName = isNull(triplet().antepenultimate()) ? null : triplet().antepenultimate().getClass().getName();
        makeScreenshot(uName);
        logDebug(b(c(ATTEMPTING), TO, RESOLVE, a(List.of(kv(EXCEPTION, eName), kv(ULTIMATE, uName), kv(PENULTIMATE,
                pName), kv(ANTEPENULTIMATE, aName)), COMMA_SPACE)));
    }

    /**
     * Determines the resolving action to be taken based on the exception message.
     *
     * @param causeMessage the exception message
     */
    private void determineTimeoutResolvingAction(final String causeMessage) {

        if (causeMessage.contains(EXPECTED_CONDITION_FAILED___)) handleExpectedCondition(causeMessage);
        else if (causeMessage.contains(AN_ELEMENT___)) resolveAnElementCouldNotBe();
        else failBecauseTimeout();
    }

    /**
     * This method represents an exceptional state encountered during testing sessions.
     * It logs an event with severity S1 and stops the execution tests.
     */
    private void notResolved() {

        logEvent(S0, UNRESOLVED___);
        stopTests();
    }

    /**
     * Logs an event with severity S1
     */
    private void resolveAnElementCouldNotBe() {

        logEvent(S1, b(PROVIDED_LOCATOR,
                q(removeEnd((core.getException().getMessage().split(lineSeparator())[5]).split(s(_EQUAL_))[2], s(CLS_CUB,
                        CLS_SBR))), WAS_NOT_REACHABLE));
    }

    /**
     * This method resolves the browser after encountering a specific exception.
     * It logs an event with severity S1 and performs specific actions based on the type of exception encountered.
     * If the error message contains certain strings, it logs additional information.
     * After processing the exception, it either restarts the browser or stops the execution tests.
     * <p>
     * The method is called internally in the action() method of the CoreExceptional class.
     */
    private void resolveBrowser() {

        logEvent(S1, b(U_B_EXCEPTION, EXCEPTION));
        restartOrStop();
    }

    private void handleExpectedCondition(final String line) {

        {
            logEvent(S1, b(PROVIDED_LOCATOR, q(removeStart(removeEnd(line, TRIED_FOR_30_SECONDS___),
                    EXPECTED_CONDITION_FAILED___)), WAS_NOT_REACHABLE));
            if (line.contains(TEXT_VIEW_TEXT)) {
                final List<WebElement> allText = findAll(_ANDROID_WIDGET_TEXTVIEW);
                log(AVAILABLE_TEXTS_OF_TEXT_VIEW_ELEMENTS);
                for (final WebElement text : allText) log(0, b(FAT_BUL, q(text.getText())), false);
            }
        }
        failBecauseTimeout();
    }

    private void resolveStale() {

        logEvent(S1, b(S_E_R_EXCEPTION, EXCEPTION));
    }

    /**
     * This method resolves any timeout exceptions encountered during testing sessions.
     * If a specific condition is met, it restarts the browser; otherwise, it stops the execution tests.
     */
    private void resolveTimeout(final Throwable cause) {

        if (isPresent(ANDROID_LAUNCHER)) restartOrStop();
        else {
            determineTimeoutResolvingAction(cause.getMessage());
            stopTests();
        }
        markAsResolved();
    }

    /**
     * This method resolves unknown timeout exceptions encountered during testing sessions.
     * It logs an event with severity S1 and a specific message using the logEvent(Severity, String) method.
     * This method is called internally in the {@link #resolveTimeout(Throwable)} method of the {@code CoreExceptional} class.
     */
    private void failBecauseTimeout() {

        logEvent(S0, b(TIMEOUT_EXCEPTION));
    }

    /**
     * Determines whether to restart the test execution by creating a new driver or stop the testing process.
     * <p>
     * The decision is based on the static `driver` property of the {@code Recreate} class.
     * If `driver` is true, it invokes the {@code createDriver()} method on the {@code execution} instance
     * to initialize a new test driver. Otherwise, it invokes the {@code stopTests()} method
     * to terminate the current testing process.
     */
    private void restartOrStop() {

        if (Recreate.driver) exec.createDriver();
        else stopTests();
    }
}